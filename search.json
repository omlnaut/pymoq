[
  {
    "objectID": "doc/general.html",
    "href": "doc/general.html",
    "title": "General structure",
    "section": "",
    "text": "from typing import Protocol\n\nclass IWeb(Protocol):\n    \"Interface for accessing internet resources\"\n    \n    def get(self, url:str, page:int, verbose:bool=False) -> str:\n        \"Fetches the ressource at `url` and returns it in string representation\"\nThe general structure of pymoqs workflows is:"
  },
  {
    "objectID": "doc/general.html#setup",
    "href": "doc/general.html#setup",
    "title": "General structure",
    "section": "Setup",
    "text": "Setup\n\nmock = Mock(IWeb)\n\nmock.get\\\n    .setup(ArbitrarySignatureValidator)\\\n    .returns(ArbitraryReturnValueGenerator)\n\nIn general, a SignatureValidator is a list of ArgumentValidator s.\nAn object following the ArgumentValidator protocol has, among other properties, a is_valid method that accepts a single argument and returns a bool, indicating if the given argument matches the expected conditions. Conditions might be a type check, a direct value check or something else entirely (e.g. “is it a string that starts with ‘py’?).\nTo make construcing a suitable list of ArgumentValidator s more convenient, there are a bunch of shortcuts for passing values to the setup method. They coded in argument_validator_from_argument. As of 2023-03-18, the shortcuts are:\n\nIf an object is passed that satisfies the ArgumentValidator Protocol, it is used without any alteration\nIf a type is passed, an ArgumentFunctionValidator is constructed that matches against that type\nIf a Callable is passed, an ArgumentFunctionValidator is constructed that passes the argument through to the callable\nIn any other case, an ArgumentFunctionValidator is constructed that matches the argument against the passed value\n\nIn the example:\n\nmock = Mock(IWeb)\nmock.get\\\n    .setup('https://some_base.com/ressource', int, False);\n\n\nThe first argument constructs a ArgumentValidator that returns true iff the string https://some_base.com/ressource is passed (last case)\nThe second argument constructs a ArgumentValidator that returns true iff the passed argument is of type int (second case)\nThe third argument constructs a ArgumentValidator that returns true iff the passed argument hast the value False (last case)\n\nThe first argument could also be an arbitrary function evaluation like:\n\nmock.get\\\n    .setup(lambda arg: isinstance(arg, str) and arg.startswith('https'), int, False);\n\nThis now matches against any arg that is of type string and starts with the substring https."
  },
  {
    "objectID": "doc/general.html#special-validators",
    "href": "doc/general.html#special-validators",
    "title": "General structure",
    "section": "Special validators",
    "text": "Special validators\nThe special validator AnyInt does a type check on int and can further be used to conveniently define int-specific validation rules, like greater_than or less_than_or_equal. See AnyInt for a list of availbe special validation rules.\nAdditionally AnyArg is available as a way to define that there is no restriction at all on the argument. This argument validator accepts any argument input."
  },
  {
    "objectID": "doc/general.html#return-action",
    "href": "doc/general.html#return-action",
    "title": "General structure",
    "section": "Return Action",
    "text": "Return Action\nIf the a call on a mock satisfies one of the setups, the corresponding return action is invoked:\n\nmock.get\\\n    .setup(ArbitrarySignatureValidator)\\\n    .returns(ArbitraryReturnValueGenerator)\n\nThe ArbitraryReturnValueGenerator is an object that follows the ReturnValueGenerator protocol. Essentially thats any callable. pymoq passes the arguments that were used in the specific call to the ReturnValueGenerator, enabling the user to return values depending on the concrete arguments used in each call.\nTo make constructing a ReturnValueGenerator more convenient, one can pass a non-callable object. pymoq constructs a ReturnValueGenerator from this that takes in any number of arguments and always returns that one value.\nE.g.\n\nmock.get\\\n    .setup('https://some_base.com/ressource', int, False)\\\n    .returns(True)\n\nassert mock.get('https://some_base.com/ressource', 0, False)\nassert mock.get('https://some_base.com/ressource', 1, False)\n\nwill always return True (if the signature matches the validator in the setup function).\nIn contrast,\n\nmock.get\\\n    .setup('https://some_base.com/ressource', int, False)\\\n    .returns(lambda self, url, page, verbose: page+1)\n\nassert mock.get('https://some_base.com/ressource', 0, False) == 1\nassert mock.get('https://some_base.com/ressource', 5, False) == 6\n\nwill return page + 1, making the return value dependent on the caller value.\n\nReturn sequence\nIt’s possible to setup a sequence of return values. For each invocation that matches the signature validator, the next value of the sequence is returned. If the sequence is empty, None is returned.\n\nmock = Mock(IWeb)\nmock.get.setup('resource', int, bool).returns_sequence([1,2,3])\n\nassert mock.get('resource', 1, True)==1\nassert mock.get('resource', 2, False)==2\nassert mock.get('resource', 3, True)==3\n\nprint(mock.get('ressource', 1, True))\n\nNone\n\n\n\n\nReturn exceptions\nA return action could also be the throwing of an exception:\n\nclass WebException(Exception):\n    \"\"\"Exception that describes web-access errors\"\"\"\n\n\nmock = Mock(IWeb)\nfetcher = RessourceFetcher(mock)\n\n# setup failing web call\nmock.get.setup('https://some_base.com/unavailable_ressource', int, bool).throws(WebException())\n\n# act and assert exception\nwith pytest.raises(WebException):\n    fetcher.check_ressource('unavailable_ressource', 1, True)\n    \n# does not raise exception if call signature does not match\nfetcher.check_ressource('available_ressource', 1, True);"
  },
  {
    "objectID": "doc/general.html#verification",
    "href": "doc/general.html#verification",
    "title": "General structure",
    "section": "Verification",
    "text": "Verification\nAfter the test method was run, one might want to verify how often certain invocations were done on the mock. The general structure for verification looks like:\nmock.get.verify(ArbitrarySignatureValidator).ArbitraryQuantor()\nThe SignatureValidator is the same as for the setup method, so look above for explanation. The Quantor defines how often a call was expected whose arguments match the SignatureValidator.\nAvailable Quantors:\n\nmock = Mock(IWeb)\nfetcher = RessourceFetcher(mock)\n\n# setup\nmock.get.setup(str, int, bool).returns(True)\n\n# act\nfetcher.check_ressource('ressource', 1)\nfetcher.check_ressource('ressource', 2)\nfetcher.check_ressource('ressource', 1, verbose=True)\n\n# assert\nmock.get.verify(str, int, bool).times(3)\nmock.get.verify(str, int, bool).more_than(1)\nmock.get.verify(str, int, bool).more_than_or_equal_to(3)\nmock.get.verify(str, int, bool).less_than(4)\nmock.get.verify(str, int, bool).less_than_or_equal_to(3)\nmock.get.verify(str, str).never()\n\nmock.get.verify(str, AnyInt('page', 2).less_than(2), bool).times(2);\n\nIt’s possible to inspect all calls that were done on the mock:\n\nmock.get.verify(str, AnyInt('page', 2).less_than(2), bool).all_calls\n\n[((None, 'https://some_base.com/ressource', 1, False), {}),\n ((None, 'https://some_base.com/ressource', 2, False), {}),\n ((None, 'https://some_base.com/ressource', 1, True), {})]\n\n\nOr only the calls that match the current signature validator:\n\nmock.get.verify(str, AnyInt('page', 2).less_than(2), bool).verified_calls\n\n[((None, 'https://some_base.com/ressource', 1, False), {}),\n ((None, 'https://some_base.com/ressource', 1, True), {})]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pymoq",
    "section": "",
    "text": "from pymoq.all import *\nFollowing the end-to-end tutorial for nbdev.\nProject homepage: github\nFull documentation: documentation"
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "pymoq",
    "section": "Install",
    "text": "Install\npip install moqpy\nThe package on pypi is called mockpy because pymoq was already taken :("
  },
  {
    "objectID": "index.html#quickstart",
    "href": "index.html#quickstart",
    "title": "pymoq",
    "section": "Quickstart",
    "text": "Quickstart\nSuppose we have the following setup in a python backend.\n\nfrom typing import Protocol\n\nclass IWeb(Protocol):\n    \"Interface for accessing internet resources\"\n    \n    def get(self, url:str, page:int, verbose:bool=False) -> str:\n        \"Fetches the ressource at `url` and returns it in string representation\"\n\n\nclass RessourceFetcher:\n    base_url: str = \"https://some_base.com/\"\n    \n    def __init__(self, web: IWeb):\n        self._web = web\n    \n    def check_ressource(self, ressource_name: str, page:int, verbose:bool=False) -> bool:\n        url = self.base_url + ressource_name\n        ressource = self._web.get(url, page, verbose)\n        \n        return ressource is not None\n\nWe want to test the fetch_ressource method of RessourceFetcher. More specifically, we want to test that if the ressource is correctly returned from the source, this method should return True, otherwise False.\n\nSetting up the mock\n\nmock = Mock(IWeb)\nmock.get\\\n    .setup('https://some_base.com/ressource', int, False)\\\n    .returns(True)\n\nfetcher = RessourceFetcher(mock)\n\nIf the call matches the siganture defined in the setup method, the lambda in returns is called and its return value is returned:\n\nassert fetcher.check_ressource('ressource', 1)\n\nIf any part of the signature does not match, None is returned:\n\nassert not fetcher.check_ressource('other_ressource', 1) # wrong ressource name\nassert not fetcher.check_ressource('ressource', \"1\") # wrong type of page argument\nassert not fetcher.check_ressource('ressource', \"1\", verbose=True) # wrong value for verbose argument\n\n\n\nVerification\nOne might want to check how often a function mock was invoked with a specific call signature. This can easily be done via the .verify method:\n\nmock = Mock(IWeb)\nfetcher = RessourceFetcher(mock)\n\n# setup\nmock.get.setup(str, int, bool).returns(True)\n\n# act\nfetcher.check_ressource('ressource', 1)\nfetcher.check_ressource('ressource', 2)\nfetcher.check_ressource('ressource', 1, verbose=True)\n\n# assert\nmock.get.verify(str, int, bool).times(3)\nmock.get.verify(str, int, bool).more_than(1)\nmock.get.verify(str, int, bool).more_than_or_equal_to(3)\nmock.get.verify(str, int, bool).less_than(4)\nmock.get.verify(str, int, bool).less_than_or_equal_to(3)\nmock.get.verify(str, str).never()\n\nmock.get.verify(str, AnyInt('page', 2).less_than(2), bool).times(2)\n\n\n\nSetup sequences\n\nmock = Mock(IWeb)\nmock.get.setup('resource', int, bool).returns_sequence([1,2,3])\n\nassert mock.get('resource', 1, True)==1\nassert mock.get('resource', 2, False)==2\nassert mock.get('resource', 3, True)==3\n\nprint(mock.get('ressource', 1, True))\n\nNone\n\n\n\n\nSetup exceptions\n\nclass WebException(Exception):\n    \"\"\"Exception that describes web-access errors\"\"\"\n\n\nmock = Mock(IWeb)\nfetcher = RessourceFetcher(mock)\n\n# setup failing web call\nmock.get.setup('https://some_base.com/unavailable_ressource', int, bool).throws(WebException())\n\n# act and assert exception\nwith pytest.raises(WebException):\n    fetcher.check_ressource('unavailable_ressource', 1, True)\n    \n# does not raise exception if call signature does not match\nfetcher.check_ressource('available_ressource', 1, True);"
  },
  {
    "objectID": "index.html#deep-dive",
    "href": "index.html#deep-dive",
    "title": "pymoq",
    "section": "Deep Dive",
    "text": "Deep Dive\nRefer to General Structure for more detail."
  },
  {
    "objectID": "implementation/verfiy.html",
    "href": "implementation/verfiy.html",
    "title": "Verification",
    "section": "",
    "text": "from pymoq.mocking.functions import FunctionMock, remove_self_parameter\n\nfrom fastcore.basics import patch_to\nfrom fastcore.test import test_fail"
  },
  {
    "objectID": "implementation/verfiy.html#proof-of-concept",
    "href": "implementation/verfiy.html#proof-of-concept",
    "title": "Verification",
    "section": "Proof of concept",
    "text": "Proof of concept\n\nfrom pymoq.mocking import objects\nfrom typing import Protocol\n\n\nMock = objects.Mock\n\n\nclass IWeb(Protocol):\n    def get(self, a: int, b:str, c:float|None=None):\n        ...\n\nCalls to the mock are recorded with the full argument list.\n\nm = Mock(IWeb)\n\nm.get(1,\"2\")\n\nm.get._calls\n\n[((None, 1, '2'), {'c': None})]\n\n\nThese can then be matched against any signature:\n\nConstructin signature validator\n\nfrom pymoq.argument_validators import AnyArg\nfrom pymoq.signature_validators import signature_validator_from_arguments\nfrom pymoq.mocking.functions import add_self_parameter\n\n\nsign_val = signature_validator_from_arguments(['self', 'a', 'b', 'c'], AnyArg(), 1, \"2\", c=AnyArg())\n\n\n\nMatching against recorded call\n\nargs, kwargs = m.get._calls[0]\nkwargs = m.get.fill_up_arg_list(args, kwargs)\n\nprint(sign_val.is_valid(*args, **kwargs))\n\nTrue"
  },
  {
    "objectID": "implementation/verfiy.html#implementation",
    "href": "implementation/verfiy.html#implementation",
    "title": "Verification",
    "section": "Implementation",
    "text": "Implementation\n\nsource\n\nVerifiedCalls\n\n VerifiedCalls\n                (verified_calls:list[tuple[list[typing.Any],dict[str,typin\n                g.Any]]], all_calls:list[tuple[list[typing.Any],dict[str,t\n                yping.Any]]])\n\n\nsource\n\n\nFunctionMock.verify\n\n FunctionMock.verify (*args, **kwargs)\n\n\nm = Mock(IWeb)\n\n\nm.get(1,\"2\")\nm.get(2,\"2\")\nm.get(2.3,\"2\")\n\ncalls = m.get.verify(int, \"2\")\nassert calls.verified == 2\nassert calls.verified_calls == [((None, 1, '2'), {'c': None}), ((None, 2, '2'), {'c': None})]\n\ncalls\n\nVerifiedCalls(verified_calls=[((None, 1, '2'), {'c': None}), ((None, 2, '2'), {'c': None})], all_calls=[((None, 1, '2'), {'c': None}), ((None, 2, '2'), {'c': None}), ((None, 2.3, '2'), {'c': None})])\n\n\n\nm.get.verify(int, \"2\").times(2)\nm.get.verify(int, \"2\").more_than(1)\nm.get.verify(int, \"2\").more_than_or_equal_to(2)\nm.get.verify(int, \"2\").less_than(3)\nm.get.verify(int, \"2\").less_than_or_equal_to(2)\nm.get.verify(str, int).never()\n\nA failing assertion gives the following error message:\n\ntry:\n    m.get.verify(int, \"2\").times(1)\nexcept Exception as e:\n    print(e)\n\nExpected 1 calls, got 2.\nMatched Calls:\n    ((None, 1, '2'), {'c': None})\n    ((None, 2, '2'), {'c': None})\nAll Calls:\n    ((None, 1, '2'), {'c': None})\n    ((None, 2, '2'), {'c': None})\n    ((None, 2.3, '2'), {'c': None})\n\n\n\ntest_fail(lambda: m.get.verify(int, \"2\").times(1))\ntest_fail(lambda: m.get.verify(int, \"2\").never())\ntest_fail(lambda: m.get.verify(int, \"2\").more_than(3))\ntest_fail(lambda: m.get.verify(int, \"2\").more_than_or_equal_to(3))\ntest_fail(lambda: m.get.verify(int, \"2\").less_than(1))\ntest_fail(lambda: m.get.verify(int, \"2\").less_than_or_equal_to(1))"
  },
  {
    "objectID": "implementation/mocking_objects.html",
    "href": "implementation/mocking_objects.html",
    "title": "Mocking objects",
    "section": "",
    "text": "Since the main purpose of pymoq is to mock interfaces (aka protocols), we need a way to extract the public members of an interface. By convention, public members should not start with an underscore.\n\n\nAll methods whose name doesn’t start with an underscore should be included. The only public method in the following class is get.\n\nclass IWeb(Protocol):    \n    def get(self, suffix:str) -> str:\n        ...\n    \n    def _internal_stuff(self) -> None:\n        ...\n\nAll names are exposed through the dir method…\n\n', '.join(dir(IWeb))\n\n'__abstractmethods__, __annotations__, __class__, __class_getitem__, __delattr__, __dict__, __dir__, __doc__, __eq__, __format__, __ge__, __getattribute__, __gt__, __hash__, __init__, __init_subclass__, __le__, __lt__, __module__, __ne__, __new__, __parameters__, __reduce__, __reduce_ex__, __repr__, __setattr__, __sizeof__, __slots__, __str__, __subclasshook__, __weakref__, _abc_impl, _internal_stuff, _is_protocol, _is_runtime_protocol, get'\n\n\n… which can be filtered for names that don’t start with an underscore:\n\nsource\n\n\n\n\n get_public_names (protocol:type)\n\nReturns all names that are considered public from the given class\n\nassert get_public_names(IWeb)==['get']\n\n\n\n\nAttributes defined in protocol classes are not directly stored in the dir list. Instead, they are accessible in __annotations__. Note that protocol variables have to be defined at class level, not inside the __init__ method.\n\nclass IStore(Protocol):\n    store_id: int\n    name: str\n    _internal_key: int\n    \n    def get(self, name:str) -> int:\n        ...\n\n\nIStore.__annotations__\n\n{'store_id': int, 'name': str, '_internal_key': int}\n\n\n\nsource\n\n\n\n\n get_public_attributes (protocol:<class'_ProtocolMeta'>)\n\nReturn a list of all attributes of the given protocol that are considered public.\n\nget_public_attributes(IStore)\n\n['store_id', 'name']\n\n\n\nassert 'store_id' in get_public_attributes(IStore)\nassert 'name' in get_public_attributes(IStore)\nassert not '_internal_key' in get_public_attributes(IStore)"
  },
  {
    "objectID": "implementation/mocking_objects.html#construction-from-protocol",
    "href": "implementation/mocking_objects.html#construction-from-protocol",
    "title": "Mocking objects",
    "section": "Construction from Protocol",
    "text": "Construction from Protocol\n\nDynamic attribute access\nDynamic attribute access is possible by overriding the special method __getattr__. This method is called when a name is not found in the current instance of the class.\n\nclass Outer:\n    def __init__(self):\n        self.valid = 2\n        self.values = {'inner': 1}\n        \n    def __getattr__(self, name: str):\n        print(f'Calling __getattr__(\"{name}\")')\n        if name in self.values:\n            return self.values[name]\n        raise AttributeError(f'Name {name} not found in values dictionary')\n        \no = Outer()\n\nAttribute is present in the class instance, so its accessed directly:\n\nprint(o.valid)\n\n2\n\n\nAttribute is not present in the class instance, so __getattr__ is called:\n\nprint(o.inner)\n\nCalling __getattr__(\"inner\")\n1\n\n\n\ntry:\n    o.invalid\nexcept Exception as e:\n    print(type(e), e)\n\nCalling __getattr__(\"invalid\")\n<class 'AttributeError'> Name invalid not found in values dictionary"
  },
  {
    "objectID": "implementation/mocking_objects.html#the-mock-object",
    "href": "implementation/mocking_objects.html#the-mock-object",
    "title": "Mocking objects",
    "section": "The Mock object",
    "text": "The Mock object\nThe Mock object is the central class that the user of pymoq will interact with. It should be initialized with a protocol, setup function-mocks for all protocol-methods and handle the call redirection to the correct mock.\n\nsource\n\nMock\n\n Mock (protocol:<class'_ProtocolMeta'>)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nmock = Mock(IWeb)\nassert str(mock) == 'Mock[IWeb]'\n\nassert list(mock._function_mocks.keys()) == ['get']\n\nmock._function_mocks\n\n{'get': <pymoq.mocking.functions.FunctionMock>}\n\n\nWhen a function is called on a Mock, it should check whether that function is part of the underlyings protocol public interface. If not, throw an AttributeError. If yes, return the appropriate function mock.\n\nmock = Mock(IWeb)\n\ntest_fail(lambda: mock.not_a_name)\nassert isinstance(mock.get, FunctionMock)\n\nWith this we can now build a working prototype of a mocked protocol.\n\nmock = Mock(IWeb)\n\nmock.get.setup(\n    ArgumentFunctionValidator(lambda a: isinstance(a, str), name='suffix', position=1)).returns(lambda self,suffix: f'suffix: {suffix}')\n\n\nassert mock.get('anyString') == 'suffix: anyString'\nassert mock.get(1) is None\ntest_fail(lambda: mock.get())"
  },
  {
    "objectID": "implementation/core.html",
    "href": "implementation/core.html",
    "title": "Core",
    "section": "",
    "text": "source\n\n\n\n AnyCallable (*args, **kwargs)\n\nGeneric interface for an object with a call operator that takes any number of arguments (both positional and named) and returns the type T"
  },
  {
    "objectID": "implementation/return_value_generators.html",
    "href": "implementation/return_value_generators.html",
    "title": "Return value generators",
    "section": "",
    "text": "Once a matching signature was found, a return value generator will be used to construct the appropriate return value. In the simplest case, this might just be returning a constant value. However, the return value could be an arbitrary function evaluation and should have access to the exact arguments that were passed.\n\nsource\n\nReturnValueGenerator\n\n ReturnValueGenerator (*args, **kwargs)\n\nConstruct a return value, potentially depended on the exact arguments used to call the function in the first place.\nThe most flexible way to implement a ReturnValueGenerator is to use a lambda:\n\nvalue_generator = lambda : 5\n\nassert isinstance(value_generator, ReturnValueGenerator)\n\nA ReturnValueGenerator that accesses the original arguments:\n\narg_value_generator = lambda a,_: a+1\n\nassert isinstance(value_generator, ReturnValueGenerator)\n\n\n\nBuild library"
  },
  {
    "objectID": "implementation/mocking.functions.html",
    "href": "implementation/mocking.functions.html",
    "title": "Mocking functions",
    "section": "",
    "text": "For a given argument list, we want to know whether the original function can be called with that set of parameters. This can be done in two steps: 1. Extract the signature 2. Try to bind the argument list against the signature. This throws an exception if the arguments can not be matched against the signature\n\n\n\ndef f(a: int, b: str, c:str|None =None) -> None:\n    pass\n\nSuccessful bind:\n\ninspect.signature(f).bind(1, \"1\", \"2\")\n\n<BoundArguments (a=1, b='1', c='2')>\n\n\nUnsuccessful bind:\n\ntry:\n    inspect.signature(f).bind(1)\nexcept Exception as e:\n    print(e)\n\nmissing a required argument: 'b'\n\n\n\n\n\nWhen binding class methods, the special case of the self parameter has to be considered.\n\nclass A:\n    def f(self, a:int):\n        return a+1\n\n\nsignature = inspect.signature(A.f)\n\ntry:\n    signature.bind(1)\nexcept Exception as e:\n    print(e)\n\nmissing a required argument: 'a'\n\n\nWe will mark a function as ‘class’-function if it has a parameter called ‘self’.\n\nsource\n\n\n\n\n is_class_method (func:pymoq.core.AnyCallable)\n\nReturns true if the given function has a parameter called ‘self’\n\nassert is_class_method(A.f)\nassert not is_class_method(f)\n\n\nsource\n\n\n\n\n remove_self_parameter (args:tuple[typing.Any])\n\nRemoves the first parameter of the argument list.\n\nsource\n\n\n\n\n add_self_parameter (args:tuple[typing.Any])\n\nAdds None to the front of the given tuple of arguments\n\nassert add_self_parameter((1,2))==(None,1,2)\nassert remove_self_parameter((None, 1,2))==(1,2)\nassert remove_self_parameter(add_self_parameter((1,2))) == (1,2)\n\n\n\n\n\nsource\n\n\n\n\n FunctionMock (func:pymoq.core.AnyCallable)\n\nMocks a function object based on its signature\n\nmock = FunctionMock(f)\n\n\nassert mock._argument_names == ['a', 'b', 'c']\n\nSuccessful binds:\n\nassert mock.arguments_valid(1, \"1\", \"2\")\nassert mock.arguments_valid(1, \"1\")\nassert mock.arguments_valid(1, \"1\", c=\"2\")\nassert mock.arguments_valid(a=1, b=\"1\", c=\"2\")\n\nNote that the types are not checked with this:\n\nassert mock.arguments_valid(1, 1)\n\nUnsuccessful binds might be:\n\ndef show_exception(func: AnyCallable):\n    try:\n        func()\n    except Exception as e:\n        print(e)\n        return\n    assert False, \"Expected Exception to be thrown\"\n\n\nshow_exception(lambda: mock.arguments_valid(1))# too few arguments\n\nmissing a required argument: 'b'\n\n\n\nshow_exception(lambda:mock.arguments_valid(1,2,3,4)) # too many arguments\n\ntoo many positional arguments\n\n\n\nshow_exception(lambda: mock.arguments_valid(1,2,d=3)) # unknown argument name\n\ngot an unexpected keyword argument 'd'\n\n\nSpecial case class method. Note that when calling arguments_valid directly, we need to pass in a dummy self argument.\n\nmock = FunctionMock(A.f)\n\nassert mock.arguments_valid(None, 1)\nshow_exception(lambda: mock.arguments_valid(None))\nshow_exception(lambda: mock.arguments_valid(None, 1,2))\n\nmissing a required argument: 'a'\ntoo many positional arguments"
  },
  {
    "objectID": "implementation/mocking.functions.html#setup",
    "href": "implementation/mocking.functions.html#setup",
    "title": "Mocking functions",
    "section": "Setup",
    "text": "Setup\nWe want to be able to create call-setups on the function mock. A setup consists of a signature validation and a return value generator. When the mock is called with a list of arguments, we check this list against the signature validator. If the call matches, we call the return value generator to generate the return value.\n\nsource\n\nSetup\n\n Setup (signature_validator:pymoq.signature_validators.SignatureValidator)\n\nThis class bundles a signature validator with a call-result-action\n\nsource\n\n\nSetup.returns\n\n Setup.returns (return_value_generator:Any)\n\nSet the ReturnValueGenerator to be called when this setup is successfully called\n\nsource\n\n\nFunctionMock.setup\n\n FunctionMock.setup (*args, **kwargs)\n\nA setup can now be defined by passing a function that takes in the call parameters and outputs the appropriate value:\n\nmock = FunctionMock(f)\n\nmock.setup(ArgumentFunctionValidator(lambda a: isinstance(a, int), name='a', position=0)).returns(lambda first, **kwargs: first+1)\nassert mock._setups[0].get_return_value(4) == 5\n\n\nassert mock._setups[0].get_return_value(4)==5\nassert mock._setups[0].get_return_value(4, a=1)==5\n\n\nassert mock._setups[0].is_valid(1)\nassert not mock._setups[0].is_valid(\"1\")\n\nor by passing a constant, which is then returned regardless of the call values:\n\nmock = FunctionMock(f)\n\nmock.setup(ArgumentFunctionValidator(lambda a: isinstance(a, int), name='a', position=0)).returns(5)\nassert mock._setups[0].get_return_value() == 5\n\n\n\nself argument on class methods\n\nclass A:\n    def f(self, a: int) -> None:\n        pass\n\n\nmock = FunctionMock(A.f)\n\nmock.setup(lambda a: isinstance(a, int)).returns(lambda self, a: 5)\n\nassert mock._setups[0].is_valid(None, 1)\n\n\nmock._setups[0]._signature_validator.argument_validators\n\n[ArgumentFunctionValidator(argument_name:self, position=0): callable(),\n ArgumentFunctionValidator(argument_name:a, position=1): callable()]"
  },
  {
    "objectID": "implementation/mocking.functions.html#call-validation",
    "href": "implementation/mocking.functions.html#call-validation",
    "title": "Mocking functions",
    "section": "Call validation",
    "text": "Call validation\nWhen called, a function mock should perform the following steps: 1. check if the argument list binds against the original functions signature 2. check if the signature validator matches for the stored Setups in order they were added 3. The first setup with a matching signature validator should be used for generating the return value\nEdge cases: - If no Setup matches, return None\n\nDealing with default-values\nThe number of arguments passed to a function call might differ from call to call if default values are used:\n\ndef f(a:int, b:str=\"str\"):\n    ...\n    \nmock = FunctionMock(f)\nmock.setup(ArgumentFunctionValidator(lambda a: True, name='a', position=0), ArgumentFunctionValidator(lambda b: True, name='b', position=1)).returns(lambda *args,**kwargs: print(args, kwargs))\n\n\nmock._setups[0].get_return_value(1), mock._setups[0].get_return_value(1, b=\"b\")\n\n(1,) {}\n(1,) {'b': 'b'}\n\n\n(None, None)\n\n\nNext, we’ll match an argument list against the default values.\n\nsource\n\n\nFunctionMock.fill_up_arg_list\n\n FunctionMock.fill_up_arg_list (args:list[typing.Any],\n                                kwargs:dict[str,typing.Any],\n                                verbose:bool=False)\n\nIf a default-value is already present via name, the default value should not be used:\n\ndef f(a: int, b: str, c:str|None ='default str') -> None:\n    pass\n\nmock = FunctionMock(f)\n\nassert mock.fill_up_arg_list([1, 1.1], {'c': 'custom str'}) == {'c': 'custom str'}\n\nIf a default-value is already overriden by a positional argument, it should not be used:\n\nassert mock.fill_up_arg_list([1, 1.1, 'custom str'], {}) == {}\n\nIf neither is the case, the default-value should be used:\n\nassert mock.fill_up_arg_list([1, 1.1], {}) == {'c': 'default str'}\n\n\n\nCall method\nCalls on a mock should be recorded. This makes it possible to unit-test that specific argument combinations were called a specific amount of time.\n\ndef f(a: int, b: str, c:str|None =None) -> None:\n    pass\n\nmock = FunctionMock(f)\n\nWithout any setup a call either fails or returns None:\n\ntest_fail(lambda: mock())\nassert mock(1,\"1\") is None\n\nNow we’ll add two setups. The first one is the more generic one that only checks if a is an int and b is a string. The second one checks if a==2 and b is a string.\n\n# this will be prettier, I promise!\nmock = FunctionMock(f)\n\n# Generic type checker\nmock.setup(\n    ArgumentFunctionValidator(lambda a: isinstance(a, int), name='a', position=0),\n    ArgumentFunctionValidator(lambda b: isinstance(b, str), name='b', position=1),\n    ArgumentFunctionValidator(lambda c: c is None, name='c', position=2)).returns(lambda a,b,c: 5)\n\n# Value checker\nmock.setup(\n    ArgumentFunctionValidator(lambda a: a==2, name='a', position=0),\n    ArgumentFunctionValidator(lambda b: isinstance(b, str), name='b', position=1),\n    ArgumentFunctionValidator(lambda c: c is None, name='c', position=2)).returns(lambda a,b,c: 6)\n\nassert mock(2, 'anyString')==6\nassert mock(1, 'anyString')==5\nassert mock(1, 1) is None\nassert mock._calls == [\n    ((2, 'anyString'), {'c': None}),\n    ((1, 'anyString'), {'c': None}),\n    ((1, 1), {'c': None})\n]\n\nLastly, the generic return value generator could be used to return a value based on the input value:\n\nmock = FunctionMock(f)\n\n# Generic type checker\nmock.setup(\n    ArgumentFunctionValidator(lambda a: isinstance(a, int), name='a', position=0),\n    ArgumentFunctionValidator(lambda b: isinstance(b, str), name='b', position=1),\n    ArgumentFunctionValidator(lambda c: c is None, name='c', position=2)).returns(lambda a,b,c: a+1)\n\nassert mock(1,'anyString')==2\nassert mock(2,'anyString')==3\n\n\n\nOn class methods\n\nclass A:\n    def f(self, a: int, b: str, c:str|None =None) -> None:\n        pass\n\n\nmock = FunctionMock(A.f)\n\n\ntest_fail(lambda: mock())\nassert mock(1, \"1\", \"c\") is None\n\n\n# this will be prettier, I promise!\nmock = FunctionMock(A.f)\n\n# Generic type checker\nmock.setup(\n    ArgumentFunctionValidator(lambda a: isinstance(a, int), name='a', position=1),\n    ArgumentFunctionValidator(lambda b: isinstance(b, str), name='b', position=2),\n    ArgumentFunctionValidator(lambda c: c is None, name='c', position=3)).returns(lambda self,a,b,c: 5)\n\n# Value checker\nmock.setup(\n    ArgumentFunctionValidator(lambda a: a==2, name='a', position=1),\n    ArgumentFunctionValidator(lambda b: isinstance(b, str), name='b', position=2),\n    ArgumentFunctionValidator(lambda c: c is None, name='c', position=3)).returns(lambda self,a,b,c: 6)\n\nassert mock(2, 'anyString')==6\nassert mock(1, 'anyString')==5\nassert mock(1, 1) is None\n\n\n\nNamed arguments in setup\n\nclass A:\n    def f(self, a: int, b: str, c:str|None =None) -> None:\n        pass\n\n\n# this will be prettier, I promise!\nmock = FunctionMock(A.f)\n\n# Generic type checker\nmock.setup(\n    ArgumentFunctionValidator(lambda a: isinstance(a, int), name='a', position=1),\n    ArgumentFunctionValidator(lambda b: isinstance(b, str), name='b', position=2),\n    c=ArgumentFunctionValidator(lambda c: c is None, name='c', position=3)).returns(lambda self,a,b,c: 5)\n\n# Value checker\nmock.setup(\n    ArgumentFunctionValidator(lambda a: a==2, name='a', position=1),\n    ArgumentFunctionValidator(lambda b: isinstance(b, str), name='b', position=2),\n    c=ArgumentFunctionValidator(lambda c: c is None, name='c', position=3)).returns(lambda self,a,b,c: 6)\n\nassert mock(2, 'anyString')==6\nassert mock(1, 'anyString')==5\nassert mock(1, 1) is None"
  },
  {
    "objectID": "implementation/signature_validators.html",
    "href": "implementation/signature_validators.html",
    "title": "Signature validators",
    "section": "",
    "text": "A signature validator is simply a collection of argument validators. Its is_valid methods checks for a given list of arguments if all argument validators return valid.\nsource"
  },
  {
    "objectID": "implementation/signature_validators.html#ease-of-use-construct-from-arguments",
    "href": "implementation/signature_validators.html#ease-of-use-construct-from-arguments",
    "title": "Signature validators",
    "section": "Ease of use: Construct from arguments",
    "text": "Ease of use: Construct from arguments\n\nsource\n\nsignature_validator_from_arguments\n\n signature_validator_from_arguments (argument_names:list[str], *args,\n                                     **kwargs)\n\nConstruct a SignatureValidator by smartly constructing ArgumentValidators when no actual argument validators are given\nIf there are actual ArgumentValidators given:\n\nsign_val = signature_validator_from_arguments(['a','b'], ArgumentFunctionValidator(lambda a: isinstance(a, int), name='a', position=0), b=ArgumentFunctionValidator(lambda b: isinstance(b, str), name='b', position=1))\n\nassert sign_val.is_valid(1, '1')\nassert not sign_val.is_valid(\"1\")\nassert not sign_val.is_valid(1,1)\n\nIf there is a callable given, a ArgumentFunctinValidator is constructed:\n\nsign_val = signature_validator_from_arguments(['a', 'b'], lambda a: isinstance(a, int), b=lambda b: isinstance(b, str))\n\nassert sign_val.is_valid(1, '1')\nassert not sign_val.is_valid(\"1\")\nassert not sign_val.is_valid(1,1)"
  },
  {
    "objectID": "implementation/validators.html",
    "href": "implementation/validators.html",
    "title": "Validators",
    "section": "",
    "text": "Goal: Evaluate whether a call like f(1,\"s\") matches any signature-pattern. A signature pattern might be defined like f(1, str). This should match any call that passes the exact value one for the first argument and any object of type str in the second."
  },
  {
    "objectID": "implementation/validators.html#argument-validators",
    "href": "implementation/validators.html#argument-validators",
    "title": "Validators",
    "section": "Argument validators",
    "text": "Argument validators\nWe break the task down to validating a single argument. The signature of such an ArgumentValidator should look like :\n\nsource\n\nArgumentValidator\n\n ArgumentValidator (*args, **kwargs)\n\nInterface for all argument validators.\nThe most flexibility can be achieved by constructing an ArgumentValidator that evaluates an arbitrary function:\n\nsource\n\n\nArgumentFunctionValidator\n\n ArgumentFunctionValidator (func:pymoq.core.AnyCallable[bool], name:str,\n                            position:int, display:str|None=None)\n\nValidate an argument by evaluating an arbitrary function\nThis could now be used like:\n\nany_int = ArgumentFunctionValidator(lambda v: isinstance(v, int), \"firstArgument\", 0, display='AnyInt()')\nany_int\n\nArgumentFunctionValidator(argument_name:firstArgument, position=0): AnyInt()\n\n\n\nassert any_int.is_valid(1)\nassert not any_int.is_valid(1.1)\nassert not any_int.is_valid(\"string\")\nassert str(any_int)=='ArgumentFunctionValidator(argument_name:firstArgument, position=0): AnyInt()'\n\nIn later stages there should be convenience methods around creating such argument validators. E.g. from_type(some_type) for making the above easier.\n\n\nEase of use: Construction from arguments\n\nsource\n\n\nargument_validator_from_argument\n\n argument_validator_from_argument (argument:Any, name:str, position:int,\n                                   verbose:bool=False)\n\n\nArgumentValidator\nPassing a valid ArgumentValidator simply returns it:\n\nassert argument_validator_from_argument(any_int, any_int.name, 0) == any_int\n\n\n\nCallable\nPassing a callable constructs an ArgumentFunctionValidator:\n\narg_val = argument_validator_from_argument(lambda v: isinstance(v, int), 'a', 0)\narg_val\n\nArgumentFunctionValidator(argument_name:a, position=0): callable()\n\n\n\ncheck_type = lambda v: isinstance(v, int)\ncheck_type.display = 'any_int'\n\narg_val = argument_validator_from_argument(check_type, 'a', 0)\narg_val\n\nArgumentFunctionValidator(argument_name:a, position=0): any_int\n\n\n\nassert isinstance(arg_val, ArgumentValidator)\nassert arg_val.is_valid(1)\nassert not arg_val.is_valid(\"1\")\n\n\n\nType\n\narg_val = argument_validator_from_argument(int, name='a', position=0)\narg_val\n\nArgumentFunctionValidator(argument_name:a, position=0): any_int\n\n\n\nassert isinstance(arg_val, ArgumentValidator)\nassert arg_val.is_valid(1)\nassert not arg_val.is_valid(\"1\")\n\n\n\nNon-callable, non-type\nPassing a non-callable assumes that the value should be compared against, i.e. it’s a constant:\n\narg_val = argument_validator_from_argument(123, name='a', position=0)\narg_val\n\nArgumentFunctionValidator(argument_name:a, position=0): == 123\n\n\n\nassert isinstance(arg_val, ArgumentValidator)\nassert arg_val.is_valid(123)\nassert not arg_val.is_valid(124)\nassert str(arg_val)=='ArgumentFunctionValidator(argument_name:a, position=0): == 123'"
  },
  {
    "objectID": "implementation/validators.html#special-validators",
    "href": "implementation/validators.html#special-validators",
    "title": "Validators",
    "section": "Special Validators",
    "text": "Special Validators\n\nsource\n\nAnyInt\n\n AnyInt (name:str, position:int, display:str|None=None)\n\nSpecial validator that provides methods for integers\n\na = AnyInt('a', 0)\n\nassert a.is_valid(1)\nassert not a.is_valid(\"1\")\na\n\nAnyInt()\n\n\n\nb = AnyInt('b', 1).greather_than(5)\n\nassert b.is_valid(6)\nassert not b.is_valid(5)\nb\n\nAnyInt().greather_than(5)\n\n\n\nb = AnyInt('b', 1).greather_than_or_equal(5)\n\nassert b.is_valid(5)\nassert not b.is_valid(4)\nb\n\nAnyInt().greather_than_or_equal(5)\n\n\n\nc = AnyInt('c', 2).less_than(5)\n\nassert c.is_valid(4)\nassert not c.is_valid(5)\nc\n\nAnyInt().less_than(5)\n\n\n\nc = AnyInt('c', 2).less_than_or_equal(5)\n\nassert c.is_valid(5)\nassert not c.is_valid(6)\nc\n\nAnyInt().less_than_or_equal(5)"
  }
]