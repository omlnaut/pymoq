[
  {
    "objectID": "validators.html",
    "href": "validators.html",
    "title": "Validators",
    "section": "",
    "text": "Goal: Evaluate whether a call like f(1,\"s\") matches any signature-pattern. A signature pattern might be defined like f(1, str). This should match any call that passes the exact value one for the first argument and any object of type str in the second."
  },
  {
    "objectID": "validators.html#argument-validators",
    "href": "validators.html#argument-validators",
    "title": "Validators",
    "section": "Argument validators",
    "text": "Argument validators\nWe break the task down to validating a single argument. The signature of such an ArgumentValidator should look like:\n\nsource\n\nArgumentValidator\n\n ArgumentValidator (*args, **kwargs)\n\nInterface for all argument validators\nThe most flexibility can be achieved by constructing an ArgumentValidator that evaluates an arbitrary function:\n\nsource\n\n\nArgumentFunctionValidator\n\n ArgumentFunctionValidator (func:pymoq.core.AnyCallable[bool])\n\nValidate an argument by evaluating an arbitrary function\nThis could now be used like:\n\nany_int = ArgumentFunctionValidator(lambda v: isinstance(v, int))\n\n\nassert any_int.is_valid(1)\nassert not any_int.is_valid(1.1)\nassert not any_int.is_valid(\"string\")\n\nIn later stages there should be convenience methods around creating such argument validators. E.g. from_type(some_type) for making the above easier."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pymoq",
    "section": "",
    "text": "Following the end-to-end tutorial for nbdev."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "pymoq",
    "section": "Install",
    "text": "Install\npip install pymoq"
  },
  {
    "objectID": "index.html#notes",
    "href": "index.html#notes",
    "title": "pymoq",
    "section": "Notes",
    "text": "Notes\n\nadded vim extensions to jupyterlab\nremoved egg-info dir from index. It caused the pipeline to fail becauce of unclean git status\nuse nbdev_prepare to\n\nbuild the library\nrun tests\nclean notebooks from metadata\nupdate readme from index notebook\n\npreview documentation\neditable install library\ninstall git hooks\ncontinue with “Check out your workflows”\ninitialized nbdev repo\ninitialized ssh access for github"
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Core",
    "section": "",
    "text": "Build library"
  },
  {
    "objectID": "argument_validators.html",
    "href": "argument_validators.html",
    "title": "Validators",
    "section": "",
    "text": "Goal: Evaluate whether a call like f(1,\"s\") matches any signature-pattern. A signature pattern might be defined like f(1, str). This should match any call that passes the exact value one for the first argument and any object of type str in the second."
  },
  {
    "objectID": "argument_validators.html#argument-validators",
    "href": "argument_validators.html#argument-validators",
    "title": "Validators",
    "section": "Argument validators",
    "text": "Argument validators\nWe break the task down to validating a single argument. The signature of such an ArgumentValidator should look like:\n\nsource\n\nArgumentValidator\n\n ArgumentValidator (*args, **kwargs)\n\nInterface for all argument validators\nThe most flexibility can be achieved by constructing an ArgumentValidator that evaluates an arbitrary function:\n\nsource\n\n\nArgumentFunctionValidator\n\n ArgumentFunctionValidator (func:pymoq.core.AnyCallable[bool])\n\nValidate an argument by evaluating an arbitrary function\nThis could now be used like:\n\nany_int = ArgumentFunctionValidator(lambda v: isinstance(v, int))\n\n\nassert any_int.is_valid(1)\nassert not any_int.is_valid(1.1)\nassert not any_int.is_valid(\"string\")\n\nIn later stages there should be convenience methods around creating such argument validators. E.g. from_type(some_type) for making the above easier."
  }
]