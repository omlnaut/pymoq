[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "source\n\nfoo\n\n foo ()\n\na new markdown cell\n\nsource\n\n\nsay_hy\n\n say_hy (to:str)\n\n\nfrom fastcore.test import *\n\n\ntest_eq(say_hy('me'), 'hy me!')"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pymoq",
    "section": "",
    "text": "Following the end-to-end tutorial for nbdev."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "pymoq",
    "section": "Install",
    "text": "Install\npip install pymoq"
  },
  {
    "objectID": "index.html#notes",
    "href": "index.html#notes",
    "title": "pymoq",
    "section": "Notes",
    "text": "Notes\n\nuse nbdev_prepare to\n\nbuild the library\nrun tests\nclean notebooks from metadata\nupdate readme from index notebook\n\npreview documentation\neditable install library\ninstall git hooks\ncontinue with “Check out your workflows”\ninitialized nbdev repo\ninitialized ssh access for github"
  },
  {
    "objectID": "old/nbs/Extending_Unittest_Mock.html",
    "href": "old/nbs/Extending_Unittest_Mock.html",
    "title": "Autospec",
    "section": "",
    "text": "from unittest.mock import create_autospec\nfrom typing import Protocol, Any"
  },
  {
    "objectID": "old/nbs/Extending_Unittest_Mock.html#creating-a-mock-based-on-a-protocol",
    "href": "old/nbs/Extending_Unittest_Mock.html#creating-a-mock-based-on-a-protocol",
    "title": "Autospec",
    "section": "Creating a mock based on a protocol",
    "text": "Creating a mock based on a protocol\n\nm = create_autospec(IWeb)\n\nm.get('url')\n\n<MagicMock name='mock.get()' id='2054874427504'>"
  },
  {
    "objectID": "old/nbs/Extending_Unittest_Mock.html#calling-function-with-invalid-signature",
    "href": "old/nbs/Extending_Unittest_Mock.html#calling-function-with-invalid-signature",
    "title": "Autospec",
    "section": "Calling function with invalid signature",
    "text": "Calling function with invalid signature\n\ntry:\n    m.get()\nexcept Exception as e:\n    print(e)\n\nmissing a required argument: 'url'\n\n\n\ntry:\n    m.get(1,2)\nexcept Exception as e:\n    print(e)\n\ntoo many positional arguments"
  },
  {
    "objectID": "old/nbs/Extending_Unittest_Mock.html#accessing-non-existing-attributes",
    "href": "old/nbs/Extending_Unittest_Mock.html#accessing-non-existing-attributes",
    "title": "Autospec",
    "section": "Accessing non-existing attributes",
    "text": "Accessing non-existing attributes\n\ntry:\n    m.func\nexcept Exception as e:\n    print(e)\n\nMock object has no attribute 'func'"
  },
  {
    "objectID": "old/nbs/Extending_Unittest_Mock.html#function-introspection",
    "href": "old/nbs/Extending_Unittest_Mock.html#function-introspection",
    "title": "Autospec",
    "section": "Function introspection",
    "text": "Function introspection\n\nIWeb.request.__kwdefaults__\n\n\nIWeb.request.__defaults__\n\n(False,)\n\n\n\ndef f(a=1):\n    pass\n\ndef g(*, a=1):\n    pass\n\n\nf.__kwdefaults__, g.__kwdefaults__\n\n(None, {'a': 1})\n\n\n\nfrom inspect import signature\n\nsig = signature(IWeb.request)\nsig\n\n<Signature (self, url: str, body: dict[str, typing.Any], verbose=False)>\n\n\n\nsig.parameters\n\nmappingproxy({'self': <Parameter \"self\">,\n              'url': <Parameter \"url: str\">,\n              'body': <Parameter \"body: dict[str, typing.Any]\">,\n              'verbose': <Parameter \"verbose=False\">})\n\n\n\np = sig.parameters['url']\np, p.default\n\n(<Parameter \"url: str\">, inspect._empty)\n\n\n\np = sig.parameters['verbose']\n\n\np.default\n\nFalse"
  },
  {
    "objectID": "old/readme.html",
    "href": "old/readme.html",
    "title": "PyMoq",
    "section": "",
    "text": "This is a recreational attempt at replicating parts of the c# moq library."
  },
  {
    "objectID": "old/readme.html#goals",
    "href": "old/readme.html#goals",
    "title": "PyMoq",
    "section": "Goals",
    "text": "Goals\n\nCreate a mock based from an interface. It should throw an error if a function is called on it that doesn’t exist on the interface\nm = Mock(IWeb)\nm.func() --> throws an error that func doesn't exist on m\nm.get() --> throws an error that function signature does not match\nSet return types based on call signature. E.g.\nm.get.setup().returns(\"default for all calls\") or\nm.get.setup(\"specific str\").returns(\"for that specific string\") or\nm.get.setup(str).returns(\"for any string\") or\nm.get.setup(ConditionType(str, lambda s: s.starts_with(\"a\"))).returns(\"for a string that matches the condition\")\nValidate calls based on signature. E.g.\nm.get.validate(\"specific str\").times(1) or\nm.get.validate(str).times(0) or\nm.get.validate(AnyType(str, lambda s: s.starts_with(\"a\"))).times(2)"
  },
  {
    "objectID": "old/readme.html#faking-attributes",
    "href": "old/readme.html#faking-attributes",
    "title": "PyMoq",
    "section": "Faking attributes",
    "text": "Faking attributes\n\nReading attributes\nListing all attributes is easy:\n\ndir(IWeb)\n\n['__abstractmethods__',\n '__annotations__',\n '__class__',\n '__class_getitem__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__parameters__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__slots__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n '_abc_impl',\n '_is_protocol',\n '_is_runtime_protocol',\n 'get']\n\n\nThese have to be filtered, we only need the ‘public’ attributes. By convention, these are the ones not starting with an underscore.\n\nfrom typing import Any, List\n\ndef is_public(name: str) -> bool:\n    return not name.startswith('_')\n\ndef get_public_attributes(cls : Any) -> List[str]:\n    return list(filter(is_public, dir(cls)))\n\n\nget_public_attributes(IWeb)\n\n['get']\n\n\n\n\nGet Function by name\nThe string name of the functions from above can easily be used to access the corresponding function objects of a class:\n\ngetattr(IWeb, 'get')\n\n<function __main__.IWeb.get(url: str) -> str>\n\n\n\n\nSignature validation\nThe inspect module gives easy access to the signature of a callable:\n\nfrom inspect import signature\n\nsig = signature(IWeb.get)\nsig\n\n<Signature (url: str) -> str>\n\n\nWe can also check if a given argument list is enough to call a function with the given signature:\n\nsig.bind('url')\n\n<BoundArguments (url='url')>\n\n\n\ntry:\n    sig.bind()\nexcept Exception as e:\n    print(e)\n\nmissing a required argument: 'url'\n\n\nFrom this, we can create a wrapper that checks for the validity of a call, then does some optional pattern matching on the given arguments.\n\nfrom typing import Callable\nimport sys\n\nclass FunctionMocker:\n    def __init__(self, target_function: Callable[[Any], Any], top_level: str=\"\"):\n        self.name = target_function.__name__\n        self.target_signature = signature(target_function)\n        self._error_prefix = f'{top_level}.' if top_level else ''\n        \n    def _validate_signature(self, *args, **kwargs):\n        try:\n            self.target_signature.bind(*args, **kwargs)\n        except TypeError as e:\n            ei = sys.exc_info()\n            raise ei[0](TypeError(f'{self._error_prefix}{self.name}{self.target_signature}: {e}')).with_traceback(ei[2].tb_next.tb_next.tb_next) from None\n            #raise ei[0], TypeError(f'{self._error_prefix}{self.name}{self.target_signature}: {e}'), ei[2].tb_next\n            #raise TypeError(f'{self._error_prefix}{self.name}{self.target_signature}: {e}') from None\n        \n    def __call__(self, *args, **kwargs):\n        self._validate_signature(*args, **kwargs)\n        \n        print('Correct signature, start pattern matching')\n        \n    def setup(self):\n        pass\n        \n    def __str__(self):\n        return f'Moq: {self.name}{self.target_signature}'\n    \n    def __repr__(self):\n        return str(self)\n\n\nf = FunctionMocker(IWeb.get)\nf('url')\n\nCorrect signature, start pattern matching\n\n\n\ntry:\n    f()\nexcept TypeError as e:\n    print(e)\n\nget(url: str) -> str: missing a required argument: 'url'\n\n\n\n\nA first simple Mocker\nWith the FunctionMocker from above we can implement a simple version of a class-specific Mocker.\n\nfrom typing import TypeVar, Type\nT = TypeVar('T')\n\nclass Moq:\n    def __init__(self, cls: Type[T]) -> T:\n        self.cls_name = cls.__name__\n        self._extract_attributes(cls)\n        \n    def _extract_attributes(self, cls):\n        self.attribute_names = get_public_attributes(cls)\n        self.moq_functions = {name: FunctionMocker(getattr(cls, name), self.cls_name)\n                              for name in self.attribute_names}\n        \n    def __getattr__(self, name):\n        if name not in self.moq_functions:\n            raise AttributeError(f\"No attribute with name '{name}' in class {self.cls_name}\")\n            \n        return self.moq_functions[name]\n    \n    def __dir__(self):\n        return dir(super()) + self.attribute_names\n\n\nm = Moq(IWeb)\n\n\ndef function_to_test():\n    a = 1\n    m.get()\n    return a+2\n\nCalling a function with an incorrect argument:\n\ntry:\n    function_to_test()\nexcept Exception as e:\n    print(e)\n\nIWeb.get(url: str) -> str: missing a required argument: 'url'\n\n\nCalling a not existing function:\n\ntry:\n    m.not_found\nexcept AttributeError as e:\n    print(e)\n\nNo attribute with name 'not_found' in class IWeb\n\n\n\nimport types\n\n\nnames = ['get']\n\n\na = type('A', (), {name: FunctionMocker(IWeb.get) for name in names})\n\n\nb = a()\n\n\ntype(b)\n\n__main__.A\n\n\n\nb.get.setup\n\n<bound method FunctionMocker.setup of Moq: get(url: str) -> str>"
  }
]